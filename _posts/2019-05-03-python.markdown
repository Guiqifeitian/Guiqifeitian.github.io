---
categories: blog
date: '2019-05-03 13:11:18'
description: it is so pythonic
layout: post
published: True
title: "something about python"
---

### 使用函数名称调用函数(方法)

##### eval

eval直接将函数字符串名称转换成函数对象

##### locals globals

locals和globals以字典形式分别返回当前位置的全部局部变量和全局变量，这就包括了定义的方法

```
>>> locals()
{'__builtins__': <module '__builtin__' (built-in)>, '__name__': '__main__', 'foo': <function foo at 0x7f4c71cfa5f0>, '__doc__': None, '__package__': None}
```

```python
def foo():
  print "foo"

eval("foo")()

locals()["foo"]()
globals()["foo"]()
```

##### getattr

当通过对象调用函数的时候，可以使用getattr

##### methodcaller

也可以使用operator模块的methodcaller调用函数

```python
class Foo():
  def foo(self):
    print "foo"

f = Foo()
getattr(f,"foo")()

from operator import methodcaller
methodcaller("foo")(f)
```

### \_\_init\_\_ 和 \_\_new\_\_

`__init__`是初始化方法，创建对象后，就立刻被默认调用了，可接收参数。`__init__`中的self参数就是`__new__`返回的对象

`__new__`必须要有返回值，返回实例化出来的实例

### is 和 ==

is是检查对象的标示符是否一致，==是检查俩个对象是否相等,`a is b`就是`id(a) == id(b)`,`a == b`就是`a.__eq__(b)`

### 内存驻留

交互式命令行，对于只包含字母、数字、下划线组成的字符串，python会自动保留一个副本，当创建新的字符串的时候就直接指向该副本,此外的字符串不会驻留在内存中，

```
>>> a = "hello world"
>>> b = "hello world"
>>> a is b
False
```

### 可变对象和不可变对象

可变对象在创建后可改变但是地址不会改变，不可变对象创建后不能改变。字典和列表是可变对象，int、字符串、元组和float是不可变对象

### join和+

在连接列表中的字符串的时候，join会优先计算需要多大的内存，一次性申请，使用+就会一步一步申请，性能比前者差。

### with语句和上下文管理器

在执行with语句时，会调用对象的`__enter__`和`__exit__`方法，拥有这俩个方法的对象，就是上下文管理器

```python
class ContextManager(object):
  def __enter__(self):
    print "enter it"

  def __exit__(self,exception_type,exception_value,traceback):
    print "exit it"
    if exception_type is None:
      print "without exception"
    else:
      print "with exception %s"% exception_value
      return False

with ContextManager():
  print "testing"
```

### finally

当try语句块中含有break、continue、return的时候，在离开try之前，finally的语句会被执行

### 单例模式

##### 使用模块

python的模块天然就是一个单例，在一个模块中生成一个对象，在其他模块中导入这个对象全部都是同一个对象。因为python在导入模块的时候会生成pyc文件，在导入的从这个pyc文件导入对象

##### 使用装饰器

```python
def Singleton(cls):
    _instance = {}

    def _singleton(*args, **kargs):
        if cls not in _instance:
            _instance[cls] = cls(*args, **kargs)
        return _instance[cls]

    return _singleton
```

##### 使用类

##### 在\_\_new\_\_方法中实现

```python
import threading
class Singleton(object):
    _instance_lock = threading.Lock()

    def __init__(self):
        pass

    def __new__(cls, *args, **kwargs):
        if not hasattr(Singleton, "_instance"):
            with Singleton._instance_lock:
                if not hasattr(Singleton, "_instance"):
                    Singleton._instance = object.__new__(cls)
        return Singleton._instance
```

##### 使用元类

```python
import threading

class SingletonType(type):
    _instance_lock = threading.Lock()
    def __call__(cls, *args, **kwargs):
        if not hasattr(cls, "_instance"):
            with SingletonType._instance_lock:
                if not hasattr(cls, "_instance"):
                    cls._instance = super(SingletonType,cls).__call__(*args, **kwargs)
        return cls._instance

class Foo(metaclass=SingletonType):
    def __init__(self,name):
        self.name = name
```

### 协程

协程通过中断实现，在执行一个协程的时候，可以随时中断，去执行另一个协程;协程是在一个线程中执行，没有线程开换的开销，不需要多线程的锁机制，不存在写变量冲突，控制共享资源不加锁。

python中使用生成器实现对协程的支持

```python
def consumer():
    r = ''
    while True:
        n = yield r
        if not n:
            return
        print('[CONSUMER] Consuming %s...' % n)
        r = '200 OK'

def produce(c):
    c.send(None)
    n = 0
    while n < 5:
        n = n + 1
        print('[PRODUCER] Producing %s...' % n)
        r = c.send(n)
        print('[PRODUCER] Consumer return: %s' % r)
    c.close()

c = consumer()
produce(c)
```

### 常用库函数

#### os

```python
import os

os.name
os.listdir(path)
os.getcwd()
os.path.abspath(path)
os.system(shell)
os.path.dirname(path)
os.path.basename(path)
os.path.join(path1,path2,...)
os.mkdir(path)
os.makedirs(path)
os.chdir(path)
os.path.isfile(path)
os.path.isdir(path)
os.path.exists(path)
```
