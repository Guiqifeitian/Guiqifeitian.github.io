---
categories: blog
date: '2019-05-03 13:11:18'
description: it is so pythonic
layout: post
published: True
title: "something about python"
---

### 使用函数名称调用函数(方法)

##### eval

eval直接将函数字符串名称转换成函数对象

##### locals globals

locals和globals以字典形式分别返回当前位置的全部局部变量和全局变量，这就包括了定义的方法

```
>>> locals()
{'__builtins__': <module '__builtin__' (built-in)>, '__name__': '__main__', 'foo': <function foo at 0x7f4c71cfa5f0>, '__doc__': None, '__package__': None}
```

```python
def foo():
  print "foo"

eval("foo")()

locals()["foo"]()
globals()["foo"]()
```

##### getattr

当通过对象调用函数的时候，可以使用getattr

##### methodcaller

也可以使用operator模块的methodcaller调用函数

```python
class Foo():
  def foo(self):
    print "foo"

f = Foo()
getattr(f,"foo")()

from operator import methodcaller
methodcaller("foo")(f)
```

### \_\_init\_\_ 和 \_\_new\_\_

`__init__`是初始化方法，创建对象后，就立刻被默认调用了，可接收参数。`__init__`中的self参数就是`__new__`返回的对象

`__new__`必须要有返回值，返回实例化出来的实例

### is 和 ==

is是检查对象的标示符是否一致，==是检查俩个对象是否相等,`a is b`就是`id(a) == id(b)`,`a == b`就是`a.__eq__(b)`

### 内存驻留

交互式命令行，对于只包含字母、数字、下划线组成的字符串，python会自动保留一个副本，当创建新的字符串的时候就直接指向该副本,此外的字符串不会驻留在内存中，

```
>>> a = "hello world"
>>> b = "hello world"
>>> a is b
False
```

### 可变对象和不可变对象

可变对象在创建后可改变但是地址不会改变，不可变对象创建后不能改变。字典和列表是可变对象，int、字符串、元组和float是不可变对象

### join和+

在连接列表中的字符串的时候，join会优先计算需要多大的内存，一次性申请，使用+就会一步一步申请，性能比前者差。

### with语句和上下文管理器

在执行with语句时，会调用对象的`__enter__`和`__exit__`方法，拥有这俩个方法的对象，就是上下文管理器

```python
class ContextManager(object):
  def __enter__(self):
    print "enter it"

  def __exit__(self,exception_type,exception_value,traceback):
    print "exit it"
    if exception_type is None:
      print "without exception"
    else:
      print "with exception %s"% exception_value
      return False

with ContextManager():
  print "testing"
```

### finally

当try语句块中含有break、continue、return的时候，在离开try之前，finally的语句会被执行

### python3字符串和字节

没有前缀的字符都是Unicode，Unicode字符串中存在无法使用字节表示的抽象文本，如果Unicode字符串需要存储在硬盘或者网络中，需要将其编码为字节序列，有以下俩种方法

```
str.encode(encoding="utf-8",errors="strict")
bytes(source,encoding,errors)
```


### 列表推导

```python
[i for i in range(10) if i%2 == 0]
```

### enumerate

```python
for index,value in enumerate(["a","b","c"]):
    print index,value
```

### zip()

```python
for item in zip([1,2,3],[5,6,7]):
    print item
```

### collections

collections中日工除了集合、元素、列表、字典意外的数据类型

```
namedtuple
deque       双端队列
ChainMap   创建多个映射的单一视图，python2似乎没有
Counter 字典的子类，用于对可哈希对象进行计数
OrderedDict 字典子类，可以保留元素的添加顺序
defaultdict 字典子类，可以调用用户自定义的工厂函数设置缺失值
```

### 单例模式

##### 使用模块

python的模块天然就是一个单例，在一个模块中生成一个对象，在其他模块中导入这个对象全部都是同一个对象。因为python在导入模块的时候会生成pyc文件，在导入的从这个pyc文件导入对象

##### 使用装饰器

```python
def Singleton(cls):
    _instance = {}

    def _singleton(*args, **kargs):
        if cls not in _instance:
            _instance[cls] = cls(*args, **kargs)
        return _instance[cls]

    return _singleton
```

##### 使用类

##### 在\_\_new\_\_方法中实现

```python
import threading
class Singleton(object):
    _instance_lock = threading.Lock()

    def __init__(self):
        pass

    def __new__(cls, *args, **kwargs):
        if not hasattr(Singleton, "_instance"):
            with Singleton._instance_lock:
                if not hasattr(Singleton, "_instance"):
                    Singleton._instance = object.__new__(cls)
        return Singleton._instance
```

##### 使用元类

```python
import threading

class SingletonType(type):
    _instance_lock = threading.Lock()
    def __call__(cls, *args, **kwargs):
        if not hasattr(cls, "_instance"):
            with SingletonType._instance_lock:
                if not hasattr(cls, "_instance"):
                    cls._instance = super(SingletonType,cls).__call__(*args, **kwargs)
        return cls._instance

class Foo(metaclass=SingletonType):
    def __init__(self,name):
        self.name = name
```

### 协程

协程通过中断实现，在执行一个协程的时候，可以随时中断，去执行另一个协程;协程是在一个线程中执行，没有线程开换的开销，不需要多线程的锁机制，不存在写变量冲突，控制共享资源不加锁。

python中使用生成器实现对协程的支持

```python
def consumer():
    r = ''
    while True:
        n = yield r
        if not n:
            return
        print('[CONSUMER] Consuming %s...' % n)
        r = '200 OK'

def produce(c):
    c.send(None)
    n = 0
    while n < 5:
        n = n + 1
        print('[PRODUCER] Producing %s...' % n)
        r = c.send(n)
        print('[PRODUCER] Consumer return: %s' % r)
    c.close()

c = consumer()
produce(c)
```

### 常用库函数

#### os

```python
import os

os.name
os.listdir(path)
os.getcwd()
os.path.abspath(path)
os.system(shell)
os.path.dirname(path)
os.path.basename(path)
os.path.join(path1,path2,...)
os.mkdir(path)
os.makedirs(path)
os.chdir(path)
os.path.isfile(path)
os.path.isdir(path)
os.path.exists(path)
```

### 装饰器

#### 用类去做装饰器

可以用于非参数化装饰器

```python
class DecoratorAsClass:
	def __init__(self,function):
		self.func = function

	def __call__(self,*args,**kwargs):
		result = self.func(*args,**kwargs)
		print "hehe"
		return result

def func():
	print "hello"

dac = DecoratorAsClass(func)
dac() # hello,hehe
```

#### 参数化装饰器

```python
def repeat(number=3):
	def actual_repeat(func):
		def wrap(*args,**kwargs):
			for i in range(number):
				result = func(*args,**kwargs)
			return result
		return wrap
	return actual_repeat

# 即使使用默认参数，也需要有括号
@repeat()
def foo():
	print "hehe"
```

#### 保留内省

以上的装饰器会让原函数时区注释文档和函数名称，使用functools可解决问题

```python
from functools import wraps

def preseving_decorator(func):
	@wraps(func)
	def wrap(*args,**kwargs):
		return func(*args,**kwargs)
	return wrap
```

#### 使用场景

- 检查参数
- 缓存：将输出保存在某个变量中，在一定时间内，如果再输入一样的参数，那么输出直接从变量中查询
- 代理：比如flask使用装饰器做路由分发，django使用装饰器做账号认证
- 上下文


### 类装饰器

调用对象自己就是调用call方法

```python
class Animal(object):
	def __call__(self,words):
		print "hello",words

cat = Animal()
cat("hehe") # hello,hehe
```
