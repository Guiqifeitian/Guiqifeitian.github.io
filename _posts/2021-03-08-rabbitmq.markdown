---
categories: blog
date: '2021-03-08 22:07:18'
title: "rabbitmq集群"
published: True
layout: post
description: rabbitmq
tags: 消息队列，rabbitmq
---

## 简单说

rabbitmq的集群使用的无主模式，相对的，就有一种叫有主的集群模式。

一般来说，有主的集群，可以通过和主节点的交互，来和整个集群交互，集群内部的变化，可以很好的隐藏起来，就和访问集群的应用解耦了，但是，代价是，如果主节点出问题，那么整个集群即可能无法工作，所以需要付出额外的成本去维护主节点，对于环境比较稳定的集群来说，可以使用有主模式，相对来说，如果集群中经常有节点掉线，那么还是建议使用无主模式。

其实，无主模式就是每个节点都是“主”,rabbitmq的每个节点都是积极的节点，像redis集群的节点，就是惰性节点，什么意思呢?比方说，你去朋友家玩，结果到他家了，他父母却说你朋友不在家，rabbitmq节点就会打电话，叫你朋友回来，你自己什么都不用做，就可以和朋友愉快地玩耍了，但是redis就会直接告诉你，你朋友在哪儿，让你自己去找你朋友。

## 一些限制

由于rabbitmq集群式按照低延迟的环境设计的，因此，某些情况下，高延迟的通信，可能会导致消息传递出现异常，不建议跨区部署rabbitmq集群

另外，由于每个rabbitmq节点都要维持整个集群的信息，这个成本很高，所以，集群的数目越多，这个成本就越高，在rabbitmq社区中，一般建议集群的上限在32-64个节点。

## 节点类型

rabbitmq又内存节点和磁盘节点，可以在启动的时候，进行配置，内存节点仅将运行时状态存在内存中，磁盘节点就将运行时状态同时存储在内存和磁盘中。

## 消息通信

当消息发送到集群的总某个节点的时候，会根据路由将改消息发送到对应的队列中，如果这个队列就在消费者连接的节点上，那么消费者就可以直接获取消息，如果这个队列在其他节点上，那么其他节点会自己将队列上的消息路由到自己，然后再发送给消费者。

这个特性可以让消费者只连接集群中的一个节点，不用管消息再集群内部如何传递的，但是，对集群来说，是增加了集群的负担，而且增大的消息的延迟

题外话：celery的broker对消息队列的支持其实比较简单，这里的简单不是说支持的类型少，而是说celery几乎不怎么愿意支持消息队列的集群，因为，要支持集群的话，往往需要客户端自己做许多额外的处理，尤其是对无主的集群，比如支持redis的集群需要客户端做很多处理，但是celery几乎不愿去做这些处理，所以在集群这块，官方推荐的是rabbitmq，因为rabbitmq的任意一节点都是主，做了原本需要客户端做的处理。

## 部署节点

一般有俩种方式部署rabbitmq集群

- 先创建一个节点，再使用rabbitmq.config创建节点
- 使用rabbitmqctl创建节点，我采取这种方式创建节点

### erlang cookies

节点之间通过cookie之间通信，相当于对称加密的密钥，这个cookie所在的文件路径默认是`/var/lib/rabbitmq/erlang.cookie`,集群之间的这个文件的值必须一致才可以通信

### 创建步骤

```
# 先停止当前服务
rabbitmmqctl stop_app

# 重置节点状态
rabbitmqctl reset

# 加入节点，这里需要在本地dns文件中/etc/hosts，将primary解析成rabbitmq节点ip
rabbitmqctl join_cluster rabbitmq@primary

# 再次启动服务
rabbitmqctl start_app
```


