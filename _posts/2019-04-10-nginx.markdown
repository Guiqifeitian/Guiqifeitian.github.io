---
categories: blog
date: '2019-04-10 16:16:18'
description: it is for nginx
layout: post
published: True
title: "Nginx it?"
---

# 一、简介

nginx是轻量级、高性能的web服务器和反向代理服务器
```conf
user  nginx;
worker_processes  1;
error_log  /var/log/nginx/error.log warn;  #定义错误日志存放地址和等级
pid        /var/run/nginx.pid; #定义pid文件存放地址
events {
    worker_connections  1024; #最大并发数
}
http {
client_max_body_size 10m; #单次请求的最大字节数
    include       /etc/nginx/mime.types; #文件扩展名和类型映射表
    default_type  application/octet-stream;     #默认文件类型
    log_format  main  '$remote_addr -$remote_user  [$time_local] "$request"  '
                      '  $status $body_bytes_sent "$http_referer"'
                      ' "$http_user_agent" "$http_x_forwarded_for"';    #定义一个名字叫main的日志格式
    access_log  /var/log/nginx/access.log  main;    #访问日志存储路径以及使用main格式的日志
    sendfile        on; # 开启高效传输模式
    tcp_nopush     on;    #累积数据包大小到一定量和响应头一起发送
    tcp_nodelay     on;    #禁用naggle算法，立即发送缓冲区数据,对keep-alived有效
    keepalive_timeout  65;    #长连接超时
   #gzip  on;    
    include /etc/nginx/conf.d/*.conf; #导入路由转发文件
server {
   server_name mobileprj.rd.company.net; #监听的域名
   listen 80;#监听的端口
   location /redmine { #根据路径分发
   proxy_redirect off; #隐藏反向代理的服务器的头信息
   proxy_set_header Host $host; #设置转发请求头的host，保留此设置，避免反向代理时无限循环重定向
   proxy_set_header X-Real-IP $remote_addr; #设置转发请求的头的X-Real-IP
   proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;# 设置转发请求头的X-Forwarded-For
   proxy_set_header User-Agent $http_user_agent; #设置转发请求头的User-Agent
   proxy_pass http://172.17.0.1:8095;    #设置转发的服务地址
   }
}
}
```

# 二、安装
### 使用包管理器安装
```
# deb
sudo apt-get install nginx

# rpm
sudo yum install nginx
```
### 使用源码安装

官网上下载源码后，解压在解压后的目录执行
```shell
./configure #可以在这一步添加配置参数,具体参数可以通过./configure --help命令查看
make && sudo make install
```

对于不同用途，建议采用不同配置
```shell
# 对于网络加速代理
./configure --with-http_ssl_module --with-htpp_realip_module --with-http_geoip_module --with-http_stub_status_module --with-openssl=${BUILD_DIR}/openssl-1.0.1p
# 对于Web服务器
./configure --with-http_stub_status_module
```

当然，可以安装第三方模块，注意依赖关系
```shell
./configure --add-module=<path>#path是第三方模块目录
```

# 三、配置指南

### 基本配置格式
```
<section> {
  <directive> <parameters>;
}
```
### 全局配置参数
```
user #配置worker进程的用户和组，如果忽略了group，则group使用该用户所在的组
worker_processes #worker进程的启动数量，
error_log #错误日志路径和等级
pid #设置记录主进程ID的文件
use #指定使用什么样的连接方法，需要配合events区段
worker_connections #最大并发数
```
### 使用include文件

```conf
include /etc/nginx/conf.d/*.conf;
```

注意这些文件要有正确的nginx语法
### HTTP的server

##### 客户端指令
```
chunked_transfer_encoding #
client_body_buffer_size #设置客户端的缓存大小
client_body_in_file_only #设置为"on"时，将客户端请求体强制写入磁盘文件
client_body_in_single_buffer #强制讲客户端请求体保存在单个缓存中
client_body_temp_path #定义一个路径，用于保存客户端请求体
client_body_timeout #该指令指定客户体成功读取的两个操作之间的时间间隔
client_header_buffer_size #为客户端请求头指定一个缓存大小，当请求头大于1KB会用到这个设置
client_header_timeout #读取整个客户端头的超时时间标准
client_max_body_size #允许的客户端的最大请求头
keepalive_disable #对于某些客户端禁用keep-alive功能，比如msie6
keepalive_requests #在一个keep-alive关闭之前可以接收多少个请求
keepalive_timeout #keep-alive连接持续多久
large_client_header_buffers #定义最大数量和最大客户端请求头大小
msie_padding #为了填充响应的大小至512字节，对于 MSIE 客户端，大于400 的状态代码会被添加注释以便满足512字节，通过启用该命令可以阻止这种行为
msie_refresh #对于 MSIE 客户端，该指令可启用发送一个 refresh 头，而不是redirect
```

##### 文件IO指令

```
aio #启用异步文件io，对于linux，需要指定directio大小，当aio生效的时候，就会自动禁用sendfile
directio #可以设置为off或者某个大小值，表示当文件大小大于等于这个值时启用directio，否则使用sendfile，对于大文件，使用aio，节省cpu，对于小文件，使用sendfile，减少拷贝，
directio_alignment #设置directio算法，默认值是512，对于xfs文件系统推荐使用4KB
open_file_cache #配置一个缓存用于存储打开文件描述符、目录查询和文件查询错误
open_file_cache_errors #启动文件查询错误缓存
open_file_cache_min_uses #open_file_cache缓存的文件描述符保留在缓存中
open_file_cache_valid #指定对open_file_cache缓存有效性检查的时间间隔
postpone_output # nginx发送给客户端最小的数值
read_ahead #内核讲预读文件的大小，如果可能的话
sendfile #将文件从磁盘拷贝到内核缓冲区，再将记录数据位置和长度的相关数据保存到socket的相关缓存
sendfile_max_chunk #在一个snedfile中复制最大数据的大小，减少阻塞调用sendfile()所花费的最长时间
```

##### Hash指令

```
server_names_hash_bucket_size #保存server_name散列表大小的桶
server_names_hash_max_size #server_name散列表最大值
types_hash_bucket_size #指定存储散列表的桶的大小
types_hash_max_size # 指定散列类型表的最大值
variables_hash_bucket_size #指定用于存储保留变量桶的大小
variables_hash_max_size #存储保留变量最大散列值的大小
```

##### socket指令

```
lingering_close #该指令指定如何保持客户端的连接，以便用于更多数据的传输
lingering_time #在使用 lingering close 指令的连接中，该指令指定客户端连接为了处理更多的数据需要保持打开连接的时间
lingering_timeout #结合 lingering close ，该指令显示 Nginx 在关闭客户端连接之前，为获得更多数据会等待多久
reset_timedout_connection
send_lowat
send_timeout
tcp_nodelay
tcp_nopush
```

### 虚拟服务器

由关键字server开始的部分都叫虚拟服务器... ...
一个虚拟服务器由listen和server\_name指令组合定义，listen指定定义了一个ip地址/端口组合或者是unix域套接字路径

```conf
listen address [:port];
listen port;
listen unix:path;
```

对于server\_name，其指令相当简单
```
*.example.com
www.example.*
.example.com
~^www\.example\.com$
~^www(\d+).example\.(com)$
```

location用于server内部，
```
location [ = | ~ | ~* | ^~ ] uri { ... }
location @name { ... }
---
=：精确匹配（必须全部相等），不可以嵌套location
~：大小写敏感
~*：忽略大小写
^~：只需匹配uri部分
@：内部服务跳转，不可以嵌套location
```

# 四、反向代理服务器
### 简介

Nginx 能够作为 一个反向代理来终结来自于客户端的请求，并且向上游服务器打开一个新请求
```conf
#转发/newuri
location /uri {
proxy_pass http://localhost:8080/newuri;
}

#转发/local
location ~ ^/local {
proxy_pass http://localhost:8080;
}

#转发/index.php?page=$1,这个$1是前面括号匹配到的内容
location / {
rewrite /(.＊)$/ /index.php?page=$1 break;
proxy_pass http://localhost:8080;
}
```

### 代理模块

```
proxy_connect_timeout # 从接受请求到连接上游服务器最长等待时间
proxy_cookie_domain # 该指令替代从上游服务器来的 Set-Cookie 头中的 domain 属性,值是一个字符串、 一个正则表达式，或者是引用的变量,但是一般情况下，response中的cookie中domain是个可选项，并不一定存在,这时就不用设置这个值
```
![avatar](/assets/images/response_cookie.png)
```
proxy_cookie_path # 替代从上游服务器来的 Set-Cookie 头中的 path 属性
proxy_headers_hash_bucket_size # 该指令指定头名字的最大值
proxy_headers_hash_max_size  # 从上游服务器接收到头的总大小
proxy_hide_header # 指定不应该传递给客户端头的列表
proxy_http_version
proxy_ignore_client_abort # 如果该指令设置为 on ，那么当客户端放弃连接后， Nginx 将不会放弃同上游服务器的连接
proxy_ignore_headers # 当处理来自于上游服务器的响应时，该指令设置哪些头可以被忽略
proxy_intercept_errors # 如果启用该指令， Nginx 将会显示配置的 error page 错误，而不是来自子上游服务器的直接响应
proxy_max_temp_file_size # 在写入内存缓冲区时，当响应与内存缓冲区不匹配时，该指令给出溢出文件的最大值
proxy_pass # 该指令指定请求被传递到的上游服务器，格式为 URL
proxy_pass_header # 该指令覆盖掉在 proxy_hide_header 指令中设置的头，允许这些头传递到客户端
proxy_pass_request_body # 如果设置为 off ， 那么该指令将会阻止请求体发送到上游服务器
proxy_pass_request_headers # 如果设置为 off ， 该指令则会阻止请求头发送到上游服务器
proxy_redirect # 重写来自于上游服务器的 Location 和 Refresh 头
proxy_set_body # 发送到上游服务器的请求体可能会被该指令的设置值修改
proxy_set_header #
proxy_temp_file_write_size # 该指令限制在同一时间内缓冲到一个临时文件的数据量， 以使得nginx 不会过长地阻止单个请求
proxy_temp_path # 该指令设定临时文件的缓冲 ， 用于缓冲从上游服务器来的文件，可以设定目录的层次
```

### 带有cookie的遗留应用程序

如果被反向代理服务器设置自己的域和路径的cookie，就要在转发这些服务器请求的时候，对域和路径进行修改
```conf
server {
server_name app.example.com;

location /legacy1 {
    proxy_cookie_domain legacy1.example.com app.example.com;
    proxy_cookie_path $uri /legacy1$uri;
    proxy_redirect default;
    proxy_pass http://legacy1.example.com/;
  }
}
```

### upstream模块

一般在做反向代理服务器的时候，会使用upstream模块进行做负载均衡或者备份服务，放在http模块中

```conf
... ...
http {
... ...
  upstream loadbalance {
    ip_hash;
    server 172.17.0.2:8095 weight=2;
    server 172.17.0.3:8095 weight=5;
    server 172.17.0.4:8095 backup;
    keepalive 32;
  }
  location / {
    proxy_set_header Connection "";
    proxy_pass http://loadbalance;
  }
}
... ...
```

```conf
ip_hash #该指令通过 IP 地址的哈希值确保客户端均匀地连接所有服务器，键值基于c类地址
keepalive #该指令指定每一个 worker 进程缓存到上游服务器的连接数。在使用 HTTP连接时， proxy_http_version 应该设置为 1.1 ，并且将 proxy_set_header 设置为 Connection ""
least_conn #该指令激活负载均衡算法，将请求发送到活跃连接数最少的那台服务器
server #该指令为 upstream 定义一个服务器地址（带有 TCP 端口号的域名、 IP地址，或者是 UNIX 域套接字)和可选参数。参数如下
#weight ：该参数设置一个服务器的优先级优于其他服务器。
#max_fails ： 该参数设置在 fail_ timeout 时间之内尝试对一个服务器连接的最大次数，如果超过这个次数，那么就会被标记为 down 。
#fail_timeout ： 在这个指定的时间内服务器必须提供响应，如果在这个时间内没有收到响应，那么服务器将会被标记为 down 状态。
#backup ： 一旦其他服务器窑机，那么仅有该参数标记的机器才会接收请求。
#down ：该参数标记为一个服务器不再接受任何请求
```

### Keepalive

如果要实现upstream长连接，则每个进程需要另外一个connection pool，里面都是长连接。一旦与后端服务器建立连接，则在当前请求连接结束之后不会立即关闭连接，而是把用完的连接保存在一个keepalive connection pool里面，以后每次需要建立向后连接的时候，只需要从这个连接池里面找，如果找到合适的连接的话，就可以直接来用这个连接，不需要重新创建socket或者发起connect()
![avatar](/assets/images/nginx_upstream_keepalive.jpg)
### 非HTTP型的上游服务器
##### memcached上游服务器
##### FastCGI上游服务器
##### SCGI
##### uWSGI
### 负载均衡
##### 负载均衡算法

轮询、ip哈希、最少连接数

##### 错误文件处理上游服务器问题

上游服务器无法响应请求的情况，在这些情况下，可以将 Nginx 配置为从它的本地磁盘提供一个文件。

```
server {
  error_page 500 502 503 504 /50x .html;
  location = /50x.html {
    root share/examples/nginx/html;
  }
}
```

# 五、反向代理高级使用
### 安全隔离

##### 使用ssl对流量进行加密

对于使用浏览器支持的ssl证书，需要付费，这里使用openssl生成一个自签ssl证书，然后进行配置

```conf
server {
listen 443 default ssl;

server_name www.example.com;

ssl_prefer_server_ciphers on;

ssl_protocols TLSvl SSLv3;

ssl_ciphers RC4:HIGH:!aNULL:!MD5:@STRENGTH;#使用RC4算法

ssl_session_cache shared:WEB:10m; # 缓存在所有工作进程之间共享

ssl_certificate /usr/local/etc/nginx/www.example.com.crt; # 指定证书

ssl_certificate_key /usr/local/etc/nginx/www.example.com.key; # 指定key

  location / {

    proxy_set_header X-FORWARDED-PROTO https;

    proxy_pass http://upstream;
  }
}
```

##### 使用ssl进行客户端身份验证

##### 基于原始IP阻止流量

在编译时，添加GeoIP模块， --with-http\_geoip\_module，并且在系统中安装了MaxMind GeoIP库，在http中，使用geoip\_country指令指定预编译数据库文件文职，通过国家代码，设置阻止/允许IP地址访问，

```conf
geoip_country /usr/local/etc/geo/GeoIP.dat
```

变量$geoip\_country\_code的值讲被设置为ISO俩个字母的原始国家码，然后根据该变量进行控制流量了，如下示例，定义变量$exclusions，默认值是0，当ip是127.0.0.1或者属于172.29.88.0/19，则该值变为1，在之后的逻辑中，当$geoip\_country\_code为CH时，将$exclusions置为1，从而允许访问
```
... ...
http {

geoip_country /usr/local/etc/geo/GeoIP.dat;

geo $exclusions {

  default 0;
  127.0.0.1 1;
  172.29.88.0/19 1;
}

  server {

    if ($geoip_country_code = "CH"){

      set $exclusions 1;
    }
    location / {
      if($exclusions ＝ "0"){
        return 403;
      }

      proxy_pass http://upstream;

     }

  }
}
```

当然，可以使用键值对存储某个ip访问的频率来决定是否限制访问

### 反向代理服务器性能调优
##### 缓冲数据

```
proxy_buffer_size #
proxy_buffering # 开启从被代理的服务器的响应内容和缓冲，on
proxy_buffers #指定用于响应上游服务器的缓冲数量和大小，默认值是 8 4K 或者8 8K
proxy_busy_buffers_size #
```

平均请求大小： 800 Byte
平均响应大小： 900 Byte
proxy\_buffers 240 4K
每个活动的连接是240个4KB缓冲，就是`240*4*1024`
假设系统能够分配给nginx的内存是768MB，就是`768*1024*1024`
得到nginx可以支持`768*1024*1024 / 240*4*1024 = 819`个活动的连接

##### 缓存数据

```
proxy_cache # 定义用于缓存的共享内存区域
proxy_cache_bypass # 指定一个或者多个字符串变量，变量的值为非空或者非零将会导致响应从上游服务器获取而不是缓存
proxy_cache_key #  该指令作为缓存 key 的一个字符串，用于存储或者获取缓存值。可能会使用变量，但是请注意避免缓存的同一个内容有多个副本
proxy_cache_path # 指定－个放置缓存响应和共享内存 zone (keys_zone=name:size ）的目录，用于存储活动的 key 和响应的元数据
```

```conf
http {

proxy_temp_path /var/spool/nginx;

# 缓冲数据的目录在/var/spool/nginx, 响应时间为6个小时，缓存大小为1G，共享内存名称叫CACHE，大小为10M，缓存文件目录层次为两层，缓存目录结构上对某个url的哈希值为 /var/spool/nginx/3/f1/4c16873c96c9db2090134be91cbf13
proxy_cache_path /var/spool/nginx keys_zone=CACHE:10m levels=1:2 inactive=6h max_size=1g;
server {
location / {
  include proxy.conf;

  # 使用CACHE缓存数据
  proxy_cache CACHE ;

  # 对任何响应代码都缓存1天
  proxy_cache_valid any 1d;

  # 在访问上游服务器时返回error、timeout、invalid_header... ...，使用缓存的数据，当数据刷新后再被载入
  proxy_cache_use_stale error timeout invalid_header updating http_500 http_502 http_503 http_504;
  proxy_pass http://upstream;
 }
}
}
```
