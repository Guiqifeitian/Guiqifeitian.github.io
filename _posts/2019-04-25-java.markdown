---
categories: blog
date: '2019-04-25 16:44:18'
layout: post
published: False
title: "Java now"
---

### 垃圾收集器和内存分配策略

在程序计数器、虚拟机栈和本地方法栈中，由于这些和线程的创建直接相关，随线程创建而生，随线程退出而灭，所以这部分的内存回收是确定的。但是*Java堆和方法区*，一个接口中多个实现类需要的内存可能不一样，一个方法的多个分支需要的内存也可能不一样，只有程序运行期间才知道会创建那些对象，这部分内存的分配和回收是动态的。

#### 判断对象是否存活

#####  引用计数法

给对象添加引用计数，当对象的引用计数为0时，说明该对象没有被使用，可以被回收。实现简单，执行效率高。python使用的就是这种方法。但是，对于相互引用，可能会导致无法回收，所以Java虚拟机并不使用这种方法。

##### 可达性分析算法

当一个对象到GC Roots没有任何引用链的时候，则判定该对象是可回收对象。

在java中，可作为GC Roots的对象包括

```
虚拟机栈(栈帧中的本地变量表)中引用的对象
方法区中静态属性引用的对象
方法区中常量引用的对象
本地方法栈中JNI引用的对象
```

##### 引用

###### 强引用

###### 软引用

SoftReference

描述一些还有用但是并非必须的对象，在内存溢出异常之前，将会回收这些对象

###### 弱引用

WeakReference

只能生存到下一次垃圾回收之前

###### 虚引用

PhantomReference

对象被回收的时候收到一个系统通知

##### 回收方法区

主要是回收废弃常量和无用的类，
