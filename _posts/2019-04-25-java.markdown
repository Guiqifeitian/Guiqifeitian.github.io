---
categories: blog
date: '2019-04-25 16:44:18'
layout: post
published: False
title: "Java now"
---

### 垃圾收集器和内存分配策略

在程序计数器、虚拟机栈和本地方法栈中，由于这些和线程的创建直接相关，随线程创建而生，随线程退出而灭，所以这部分的内存回收是确定的。但是*Java堆和方法区*，一个接口中多个实现类需要的内存可能不一样，一个方法的多个分支需要的内存也可能不一样，只有程序运行期间才知道会创建那些对象，这部分内存的分配和回收是动态的。

#### 判断对象是否存活

#####  引用计数法

给对象添加引用计数，当对象的引用计数为0时，说明该对象没有被使用，可以被回收。实现简单，执行效率高。python使用的就是这种方法。但是，对于相互引用，可能会导致无法回收，所以Java虚拟机并不使用这种方法。

##### 可达性分析算法

当一个对象到GC Roots没有任何引用链的时候，则判定该对象是可回收对象。

在java中，可作为GC Roots的对象包括

```
虚拟机栈(栈帧中的本地变量表)中引用的对象
方法区中静态属性引用的对象
方法区中常量引用的对象
本地方法栈中JNI引用的对象
```

##### 引用

###### 强引用

###### 软引用

SoftReference

描述一些还有用但是并非必须的对象，在内存溢出异常之前，将会回收这些对象

###### 弱引用

WeakReference

只能生存到下一次垃圾回收之前

###### 虚引用

PhantomReference

对象被回收的时候收到一个系统通知

##### 回收方法区

主要是回收废弃常量和无用的类，


# 运行时数据区

- 方法区
- 堆
- 虚拟机栈
- 本地方法栈
- 程序计数器：当前线程执行的字节码行号指示器，如果当前线程正在执行native方法，这个计数器的值为Undefined

虚拟机栈： 保存Java方法执行的内存模型，每个方法在执行时都会创建一个栈帧，存储局部变量表、操作数栈、动态连接、方法出口等信息，其中，**局部变量表**存储着编译期可知的基本数据类型、对象引用、returnAddress类型。  如果线程请求的栈深度大于虚拟机所允许的深度，将StackOverflowError；虚拟机栈可以动态扩展，如果扩展时无法请求到足够的内存，将OutOfMemory

本地方法栈：与虚拟机栈相似，执行的是Native方法

Java堆： 一般来说，所有的对象实例和数组都在此分配，但也有栈上分配、标量替换等技术，这个区也是垃圾收集器管理的主要区域，如果堆中没有内存完成实例分配，将OutOfMemory

方法区：存储虚拟机加载的类信息、常量、静态变量、jit编译后的代码等，如果没有内存完成实例分配，将OutOfMemory

运行常量池：是方法区的一部分，存放编译期生成的字面量和符号引用

直接内存：nio相关

# 对象的创建

new指令创建对象

1. 检查参数能否在常量池中定位到一个类的符号引用，并检查这个类是否已被加载、解析、初始化，如果没有，先执行相关过程
2. 从java堆中划分出区域，为对象分配内存： 指针碰撞、空闲列表，线程安全：同步处理，CAS和失败重试；本地分配缓冲TLAB，-XX：+/-UseTLAB
3. 将内存空间初始化为0值，不包括对象头
4. 相关设置，设置Object Header信息

对象头 Object Header
实例数据 Instance Data
对齐填充 Padding

对象头包含：
1. 自身运行时数据，哈希码、GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳
2. 类型指针，指向类元数据的指针
3. 数组长度，如果对象是数组

实例数据
代码中定义的各种类型字段
虚拟机分配策略：longs/doubles、ints、shorts/chars、bytes/booleans、oops 相同宽度的总是分配到一起，父类的定义的变量出现在子类之前，CompactFields=true，那么也会出现子类交窄的变量插入父类的空隙之中

对象访问定位
- 句柄访问： 堆中划分出句柄池，存放着对象实例数据的指针和对象类型数据的指针
- 直接指针访问：

堆参数： -Xms20m -Xmx20m
栈参数: -Xss128k
方法区参数： -XX:PermSize=10m -XX:MaxPermSize=10M

# 垃圾回收

## 引用计数

Java中很少采用，无法解决循环引用问题

## 可达性分析法

当一个对象不可达GCRoots节点的时候，该对象可被回收

可以作为GCRoots的对象包括以下几种
- 虚拟机栈中引用的对象
- 方法区中静态类型属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象

要回收对象时候，还需要俩次标记：
- 当对象可达性分析后，对象没有与GC Roots相引用的链，那么对象会被第一次筛选，当对象没有覆盖finalize方法、或者finalize方法已经被虚拟机栈调用过，虚拟机将这俩种情况都是为没有必要执行
- 如果这个对象有必要执行finalize，那么这个对象会被放到F-Queue队列中，之后，由Finalizer线程去执行

